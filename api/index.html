<!DOCTYPE html>
<html>
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>API | OnionSkin</title>
<meta name="description" content="API for OnionSkin - A Multilayer Cache Manager for JavaScript">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="app/bower_components/bootstrap/dist/css/bootstrap.min.css">
<link rel="stylesheet" href="../app/bower_components/prism/themes/prism.css">
<link rel="stylesheet" href="../assets/main.css">
<link rel="stylesheet" href="../assets/docs.css">
<link href='http://fonts.googleapis.com/css?family=Raleway:300' rel='stylesheet' type='text/css'>
</head>
<body>
<nav>
  <img src="../assets/onionskin.png" alt="OnionSkin Logo">
  <h1 class="logo">OnionSkin</h1>
  <ul>
    <li>
      <a href="#">
        OnionSkin
      </a>
      <ul>
        <li>
          <a href="#onionskin-pool">
            Constructor → OnionSkin.Pool
          </a>
        </li>
        <li>
          <a href="#onionskin-item-cachepolicies">
            Cache Policies →<br>OnionSkin.Item Cache Policies
          </a>
        </li>
      </ul>
    </li>
    <li>
      <a href="#onionskin-pool">
        OnionSkin.Pool
      </a>
      <ul>
        <li>
          <a href="#onionskin-pool-constructor">
            Constructor
          </a>
        </li>
        <li>
          <a href="#onionskin-pool-getitem">
            getItem
          </a>
        </li>
        <li>
          <a href="#onionskin-pool-flush">
            flush
          </a>
        </li>
        <li>
          <a href="#onionskin-pool-get">
            get
          </a>
        </li>
      </ul>
    </li>
    <li>
      <a href="#onionskin-item">
        OnionSkin.Item
      </a>
      <ul>
        <li>
          <a href="#onionskin-item-constructor">
            Constructor
          </a>
        </li>
        <li>
          <a href="#onionskin-item-cachepolicies">
            Cache Policies
          </a>
          <ul>
            <li>
              <a href="#onionskin-item-cpnone">
                CP_NONE
              </a>
            </li>
            <li>
              <a href="#onionskin-item-cpold">
                CP_OLD
              </a>
            </li>
            <li>
              <a href="#onionskin-item-cpprecompute">
                CP_PRECOMPUTE
              </a>
            </li>
            <li>
              <a href="#onionskin-item-cpvalue">
                CP_VALUE
              </a>
            </li>
          </ul>
        </li>

        <li>
          <a href="#onionskin-item-get">
            get
          </a>
        </li>
        <li>
          <a href="#onionskin-item-set">
            set
          </a>
        </li>
        <li>
          <a href="#onionskin-item-save">
            save
          </a>
        </li>
        <li>
          <a href="#onionskin-item-ismiss">
            isMiss
          </a>
        </li>
        <li>
          <a href="#onionskin-item-clear">
            clear
          </a>
        </li>
        <li>
          <a href="#onionskin-item-lock">
            lock
          </a>
        </li>
        <li>
          <a href="#onionskin-item-unlock">
            unlock
          </a>
        </li>
        <li>
          <a href="#onionskin-item-islocked">
            isLocked
          </a>
        </li>
      </ul>
    </li>
    <li>
      <a href="#onionskin-drivers">
        OnionSkin.Drivers
      </a>
      <ul>
        <li>
          <a href="#onionskin-drivers-ephemeral">
            Epehemeral
          </a>
        </li>
        <li>
          <a href="#onionskin-drivers-localstorage">
            LocalStorage
          </a>
        </li>
        <li>
          <a href="#onionskin-drivers-indexeddb">
            IndexedDB
          </a>
        </li>
        <li>
          <a href="#onionskin-drivers-memcached">
            Memcached
          </a>
        </li>
        <li>
          <a href="#onionskin-drivers-redis">
            Redis
          </a>
        </li>
      </ul>
    </li>
    <li>
      <a href="#onionskin-drivers-api">
        Drivers API
      </a>

      <ul>
        <li>
          <a href="#onionskin-drivers-put">
            put
          </a>
        </li>
        <li>
          <a href="#onionskin-drivers-delete">
            delete
          </a>
        </li>
        <li>
          <a href="#onionskin-drivers-flush">
            flush
          </a>
        </li>
        <li>
          <a href="#onionskin-drivers-lock">
            lock
          </a>
        </li>
        <li>
          <a href="#onionskin-drivers-unlock">
            unlock
          </a>
        </li>
        <li>
          <a href="#onionskin-drivers-islocked">
            isLocked
          </a>
        </li>
      </ul>
    </li>
    <li>
      <a href="#onionskin-drivers-utils">
        OnionSkin.Drivers.Utils
      </a>
      <ul>
        <li>
          <a href="#onionskin-drivers-utils-key">
            key
          </a>
        </li>
        <li>
          <a href="#onionskin-drivers-utils-assemble">
            assemble
          </a>
        </li>
      </ul>
    </li>
  </ul>
</nav>

<main>
<section id="onionskin-pool">
  <section id="onionskin-pool-constructor">
    <h1>new OnionSkin.Pool([drivers])</h1>
    <p>
      Create a new cache pool that will manage the givern drivers
    </p>

    <section class="aliases">
      <h1>Aliases</h1>
      <p>new OnionSkin([drivers])</p>
    </section>

    <section class="arguments">
      <h1>Arguments</h1>
      <ol>
        <li>
          <span class="name">[drivers]</span>
          (Driver|Driver[]): The drivers that will be managed by the created pool
        </li>
      </ol>
    </section>
    <section class="return">
      <h1>Returns</h1>
      (Pool): A new pool
    </section>
    <section class="example">
      <h1>Example</h1>
      <pre>
        var pool = new OnionSkin();
        var pool = new OnionSkin([driver1, driver2]);
      </pre>
    </section>
  </section>

  <section id="onionskin-pool-getitem">
    <h1>pool.getItem(key)</h1>
    <p>
      Fetch an
      <a href="#onionskin-item">Item</a>
      from the pool
    </p>

    <section class="arguments">
      <h1>Arguments</h1>
      <ol>
        <li>
          <span class="name">key</span>
          (String|Array): The key for the cache data
        </li>
      </ol>
    </section>

    <section class="return">
      <h1>Returns</h1>
      (Item): The Item fetched
    </section>

    <section class="example">
      <h1>Example</h1>
      <pre>
        var item = pool.getItem('user/1');
        item.get(); // get item's actual data
      </pre>
    </section>
  </section>

  <section id="onionskin-pool-flush">
    <h1>pool.flush()</h1>
    <p>
      Flush the entire cache pool.
      It will basically call
      <a href="#onionskin-drivers-flush">driver.flush</a>
      on each driver
    </p>

    <section class="returns">
      <h1>Returns</h1>
      (Promise): A promise that will be resolved when all drivers have been flushed
    </section>

    <section class="example">
      <h1>Example</h1>
      <pre>
        var pool = new OnionSkin();
        pool.flush();
      </pre>
    </section>
  </section>

  <section id="onionskin-pool-get">
    <h1>pool.get(key, [cachePolicy], [policyData])</h1>
    <p>
      A shortcut for pool.getItem + item.get + item.isMiss + item.lock
    </p>
    
    <section class="arguments">
      <h1>Arguments</h1>
      <ol>
        <li>
          <span class="name">key</span>
          (String|Array): The key to be fetched
        </li>
        <li>
          <span class="name">cachePolicy</span>
          The
          <a href="#onionskin-item=cachepolicies">Cache Policy</a>
          to be used - defaults to CP_NONE
        </li>
        <li>
          <span class="name">policyData</span>
          (*): The value for the cache policy, if it needs one.
          <a href="#onionskin-item-cachepolicies">more</a>
        </li>
      </ol>
    </section>
    
    <section class="returns">
      <h1>Returns</h1>
      (Promise): A promise that will be reject if that cache is missed or resolved with the item's data
    </section>
    
    <section class="example">
      <h1>Example</h1>
      <pre>
        pool.get('user/facebook_data').catch(function (err) {
          // Cache is missing
          return fetchData().then(this.save);
        });
      </pre>
    </section>
  </section>
</section>

<section id="onionskin-item">
  <section id="onionskin-item-constructor">
    <h1>new OnionSkin.Item(key, pool)</h1>
    <p>
      Constructor used internally on
      <a href="#onionskin-pool-getitem">pool.getitem</a>
      calls
    </p>

    <section class="arguments">
      <h1>Arguments</h1>
      <ol>
        <li>
          <span class="name">key</span>
          (String|Array): The cache key that this Item will represent
        </li>
        <li>
          <span class="name">pool</span>
          (Pool): The pool where this key will be contained
        </li>
      </ol>
    </section>

    <section class="returns">
      <h1>Returns</h1>
      (Item): the created instance of Item
    </section>

    <section class="example">
      <h1>Example</h1>
      <pre>
        var pool = new OnionSkin();
        var item = new Item(key, pool); // Same as pool.getItem(key)
      </pre>
    </section>
  </section>

  <section id="onionskin-item-cachepolicies">
    <h1>Cache Policies</h1>
    <p>
      There are 4 cache policies that will affect how OnionSkin interprets cache
      locks and thereof the behavior of 
      <a href="#onionskin-item-ismissed">isMissed</a>
      method
    </p>

    <section id="onionskin-item-cpnone">
      <h1>OnionSkin.Item.CP_NONE</h1>
      <p>
        Ignore completely whether the cache is locked or not.
        Will always return true for an expired cached.
      </p>
      <section class="aliases">
        <h1>Aliases</h1>
        <p>OnionSkin.CP_NONE</p>
      </section>

      <section class="example">
        <h1>Example</h1>
        <pre>
          item.get(OnionSkin.CP_NONE);
          item.get(OnionSkin.Item.CP_NONE);
        </pre>
      </section>
    </section>

    <section id="onionskin-item-cpold">
      <h1>OnionSkin.Item.CP_OLD</h1>
      <p>
        isMissed will return false for an expired cache ifsome other instance is
        already generating this cache, e.g. this cache key is locked
      </p>
      <section class="aliases">
        <h1>Aliases</h1>
        <p>OnionSkin.CP_OLD</p>
      </section>

      <section class="example">
        <h1>Example</h1>
        <pre>
          item.get(OnionSkin.CP_OLD);
          item.get(OnionSkin.Item.CP_OLD);
        </pre>
      </section>
    </section>

    <section id="onionskin-item-cpprecompute">
      <h1>OnionSkin.Item.CP_PRECOMPUTE</h1>
      <p>
        isMiss will eventually return true for a non expired cached before it
        time** before expires<br>
        ** time should be passed along with the policy on item.get as policyData
      </p>
      <section class="aliases">
        <h1>Aliases</h1>
        <p>OnionSkin.CP_PRECOMUPTE</p>
      </section>

      <section class="example">
        <h1>Example</h1>
        <pre>
          item.get(OnionSkin.CP_PRECOMUPTE, 180);
          item.get(OnionSkin.Item.CP_PRECOMUPTE, 180);
        </pre>
      </section>
    </section>

    <section id="onionskin-item-cpvalue">
      <h1>OnionSkin.Item.CP_VALUE</h1>
      <p>
      Returns the value** specified if cache isLocked<br>
      ** value should be passed along with the policy on item.get as policyData
      </p>
      <section class="aliases">
        <h1>Aliases</h1>
        <p>OnionSkin.CP_VALUE</p>
      </section>

      <section class="example">
        <h1>Example</h1>
        <pre>
          item.get(OnionSkin.CP_VALUE, 'foo');
          item.get(OnionSkin.Item.CP_VALUE, 'not found');
        </pre>
      </section>
    </section>
  </section>

  <section id="onionskin-item-get">
    <h1>item.get([cachePolicy], [policyData])</h1>
    <p>
      Returns the actual data for the item's key based on the item's state
      (wheter it's expired or locked), the cache policy and policy data
    </p>

    <section class="arguments">
      <h1>Arguments</h1>
      <ol>
        <li>
          <span class="name">cachePolicy</span>
          (Integer): One of the 
          <a href="#onionskin-item-cachepolicies">available cache policies</a>
        </li>
        <li>
          <span class="name">policyData</span>
          (*): The value acording to the
          <a href="#onionskin-item-cachepolicies">cache policy</a>
        </li>
      </ol>
    </section>

    <section class="returns">
      <h1>Returns</h1>
      (Promise): A Promise that will be resolved with the data associated with
      the item's key or null if there wasn't anythin stored
    </section>

    <section class="example">
      <h1>Example</h1>
      <pre>
        item.get(OnionSkin.CP_OLD);
        item.get(OnionSkin.CP_PRECOMPUTE, 180);
        item.get(OnionSkin.CP_VALUE, 'default value');
      </pre>
    </section>
  </section>

  <section id="onionskin-item-set">
    <h1>item.set(value, [expiration])</h1>
    <p>
      Saves the given value to item's key, during a given time or, by default,
      until it is invalidated
    </p>

    <section class="arguments">
      <h1>Arguments</h1>
      <ol>
        <li>
          <span class="name">value</span>
          (*): The value to be associated with the item's key
        </li>
        <li>
          <span class="name">expiration</span>
          (Integer|Date): How long the cache will last before it expires,
          in seconds, or the Date when it expires
        </li>
      </ol>
    </section>

    <section class="returns">
      <h1>Returns</h1>
      (Promise): A Promise that will be resolved when the value has been written
      to all drivers
    </section>

    <section class="example">
      <h1>Example</h1>
      <pre>
        pool.get('my/key').set('my value');
        pool.get('my/other/key').set('my other value', 1800);
      </pre>
    </section>
  </section>

  <section id="onionskin-item-save">
    <h1>item.save(value, [expiration])</h1>
    <p>
      Alias to set to be used on chaining
      It will call set and return the value next
      For compatibility reasons the expiration is also accepted
    </p>

    <section class="arguments">
      <h1>Arguments</h1>
      <ol>
        <li>
          <span class="name">value</span>
          (*): The value to be associated with the item's key
        </li>
        <li>
          <span class="name">expiration</span>
          (Integer|Date): How long the cache will last before it expires,
          in seconds, or the Date when it expires
        </li>
      </ol>
    </section>

    <section class="returns">
      <h1>Returns</h1>
      (*): The value received as the first argument
    </section>

    <section class="example">
      <h1>Example</h1>
      <pre>
        item.get('key').catch(function (err) {
          //cache is missing (expired or non existing)
          return getData().then(this.save);
        });
      </pre>
    </section>
  </section>

  <section id="onionskin-item-ismiss">
    <h1>item.isMiss()</h1>
    <p>
      Check whether a stored value for the item's key is still valid to be used
      or it needs to be regenerated
    </p>

    <section class="returns">
      <h1>Returns</h1>
      (Promise): A Promise that will be resolved with a boolean value indicating
      the cache state
    </section>

    <section class="example">
      <pre>
        item.isMiss().then(function (missed) {
          if (missed) {
            regenerateData();
          }
        });
      </pre>
    </section>
  </section>

  <section id="onionskin-item-clear">
    <h1>item.clear()</h1>
    <p>
      Clear the value associated with the item's key
    </p>

    <section class="returns">
      <h1>Return</h1>
      (Promise): A Promise that will be resolved when all the drivers have been
      cleared
    </section>

    <section class="example">
      <pre>
        pool.get('my/key').clear().then(function () {
          // there is no value associated with my/key anymore
        });
      </pre>
    </section>
  </section>

  <section id="onionskin-item-lock">
    <h1>item.lock()</h1>
    <p>
      Locks the item's key indicating that its cache is already being regenerated
    </p>

    <section class="returns">
      <h1>Returns</h1>
      (Promise): A Promise that will be resolved when the item is lock has been
      written to all drivers
    </section>

    <section class="example">
      <pre>
        pool.get('my/key').lock().then(function () {
          // item is already locked for all drivers
        });
      </pre>
    </section>
  </section>

  <section id="onionskin-item-unlock">
    <h1>item.unlock()</h1>
    <p>
      Unlocks the item's key indicating that its cache has already been written
    </p>

    <section class="returns">
      <h1>Returns</h1>
      (Promise): A Promise that will be resolved when the is lock has been
      removed from all drivers
    </section>

    <section class="example">
      <pre>
        pool.get('my/key').unlock().then(function () {
          // item is already unlocked in all drivers
        });
      </pre>
    </section>
  </section>
  <section id="onionskin-item-islocked">
    <h1>item.isLocked()</h1>
    <p>
      Check if the item's key is currently locked by another instance 
    </p>

    <section class="returns">
      <h1>Return</h1>
      (Promise): A Promise that will be resolved with a boolean value
      indicating wheter this key is locked or not
    </section>

    <section class="example">
      <pre>
        pool.getItem('my/key').isLocked().then(function (locked) {
          // (Boolean): locked indicates the item's key state
        });
      </pre>
    </section>
  </section>
</section>

<section id="onionskin-drivers">
  <h1>OnionSkin has 5 drivers</h1>
  <p>
    You can combine any number of Drivers and pass to the OnionSkin constructor
    in the order you want then to be checked<br>
    OnionSkin also filters out unavailable drivers so that you don't have to 
    worry with that across different browsers
    
  </p>

  <pre>
    var pool = new OnionSkin([
      new OnionSkin.Drivers.Ephemeral(),
      new OnionSkin.Drivers.LocalStorage(),
      new OnionSkin.Drivers.IndexedDB(),
      new OnionSkin.Drivers.Memcached(),
      new OnionSkin.Drivers.Redis()
    ]);
  </pre>

  <section id="onionskin-drivers-ephemeral">
    <h1>new OnionSkin.Drivers.Ephemeral()</h1>
    <p>
      Ephemeral is the in memory cache driver
    </p>

    <section class="example">
      <h1>Example</h1>
      <pre>
        var driver = new OnionSkin.Drivers.Ephemeral();
      </pre>
    </section>
  </section>

  <section id="onionskin-drivers-localstorage">
    <h1>new OnionSkin.Drivers.LocalStorage([namespace])</h1>
    <p>
      The driver to store cache on the browser's localStorage
    </p>

    <section class="example">
      <h1>Example</h1>
      <pre>
        new OnionSkin.Drivers.LocalStorage();
        new OnionSkin.Drivers.LocalStorage('my-custom-namespace');
      </pre>
    </section>
  </section>

  <section id="onionskin-drivers-indexeddb">
    <h1>new OnionSkin.Drivers.IndexedDB([namespace])</h1>
    <p>
      Driver to store the cache on browser's IndexedDB
    </p>

    <section class="example">
      <h1>Example</h1>
      <pre>
        new OnionSkin.Drivers.IndexedDB();
        new OnionSkin.Drivers.IndexedDB('my-custom-namespace');
      </pre>
    </section>
  </section>

  <section id="onionskin-drivers-memcached">
    <h1>new OnionSkin.Drivers.Memcached([serverLocations], [options])</h1>
    <p>
      Driver to store cache on
      <a href="http://memcached.org/">Memcached</a><br>
      It encapsulates
      <a href="https://github.com/3rd-Eden/node-memcached">node-memcached</a>
      and the constuctor arguments will be passed to its constructor.
    </p>

    <section class="example">
      <h1>Example</h1>
      <pre>
        new OnionSkin.Drivers.Memcached();
        new OnionSkin.Drivers.Memcached('192.168.0.102:11212');
        new OnionSkin.Drivers.Memcached({
          '192.168.0.102:11212': 1,
          '192.168.0.103:11212': 2,
          '192.168.0.104:11212': 1
        });

        new OnionSkin.Drivers.Memcached('localhost:11212', {
          retries: 10,
          retry: 10000,
          remove: true,
          failOverServers: ['192.168.0.103:11212']
        });
      </pre>
    </section>
  </section>

  <section id="onionskin-drivers-redis">
    <h1>new OnionSkin.Drivers.Redis([port], [host], [options])</h1>
    <p>
      Driver to store cache on <a href="http://redis.io/">Redis</a><br>

      It encapsulates <a href="https://github.com/mranney/node_redis">node-redis</a> and the constuctor arguments
      will be passed to <a href="https://github.com/mranney/node_redis#rediscreateclientport-host-options">redis.createClient</a>
    </p>

    <section class="example">
      <h1>Example</h1>
      <pre>
        new OnionSkin.Drivers.Redis();
        new OnionSkin.Drivers.Redis('/tmp/redis.sock');
        new OnionSkin.Drivers.Redis('127.0.0.1', 6379, { detect_buffers: true });
      </pre>
    </section>
  </section>

  <section id="onionskin-drivers-api">
    <h1>All Drivers implement the following API</h1>

    <section id="onionskin-drivers-get">
      <h1>driver.get(key)</h1>
      <p>
        Get the value associated with the given key
      </p>

      <section class="arguments">
        <h1>Arguments</h1>
        <ol>
          <li>
            <span class="name">key</span>
            (String|Array): the key where the value will be searched
          </li>
        </ol>
      </section>

      <section class="returns">
        <h1>Returns</h1>
        (Promise): A Promise that will be resolved with the value associated with
        the key or null if nothing has been found
      </section>

      <section class="example">
        <h1>Example</h1>
        <pre>
          var driver = new OnionSkin.Drivers.Ephemeral();
          driver.get('my/key').then(function (data) {
            // do something with data...
          });

          driver.get(['my', 'key']).then(function (data) {
            // do some other thing with data...
          });
        </pre>
      </section>
    </section>

    <section id="onionskin-drivers-put">
      <h1>driver.put(key, value, [expiration])</h1>
      <p>
        Associates a value (and possibly its expiration time) with a key on the
        driver
      </p>

      <section class="arguments">
        <h1>Arguments</h1>
        <ol>
          <li>
            <span class="name">key</span>
            (String|Array): The key where the value will be stored
          </li>

          <li>
            <span class="name">value</span>
            (*): The value to be associated with key
          </li>

          <li>
            <span class="name">expiration</span>
            (Integer): The duration of the cache (in seconds) - Note: not on every
            driver the value will actually be cleared after it is expired, the
            cache validation is made by
            <a href="#onionskin-item">Item</a>
          </li>
        </ol>
      </section>

      <section class="returns">
        <h1>Returns</h1>
        (Promise): A Promise that will be resolved when the value has finished
        writting the value to the key
      </section>

      <section class="example">
        <h1>Example</h1>
        <pre>
          var driver = new OnionSkin.Drivers.LocalStorage();
          driver.put('my/key', 'my value', 1800).then(function () {
            // The value has been written
          });
        </pre>
      </section>
    </section>

    <section id="onionskin-drivers-delete">
      <h1>driver.delete(key)</h1>
      <p>
        Actually remove a key and all its subpaths from driver 
      </p>

      <section class="arguments">
        <h1>Arguments</h1>
        <ol>
          <li>
            <span class="name">key</span>
            (String|Array): The key to be deleted from driver
          </li>
        </ol>
      </section>

      <section class="returns">
        <h1>Returns</h1>
        (Promise): A Promise that will be resolved when the key and all it subkeys
        have been removed from the driver
      </section>

      <section class="example">
        <h1>Example</h1>
        <pre>
          var driver = new OnionSkin.Drivers.IndexedDB();
          driver.delete(['my', 'key']).then(function () {
            // The key has been removed
          });
        </pre>
      </section>
    </section>

    <section id="onionskin-drivers-flush">
      <h1>driver.flush()</h1>
      <p>
        Flush the entire driver data
      </p>

      <section class="returns">
        <h1>Returns</h1>
        (Promise): A Promise that will be resolved when the entire data has been
        flushed
      </section>

      <section class="example">
        <h1>Example</h1>
        <pre>
          var driver = new OnionSkin.Drivers.Memcached();
          driver.flush().then(function () {
            // OK, now driver is empty
          });
        </pre>
      </section>
    </section>

    <section id="onionskin-drivers-lock">
      <h1>driver.lock(key)</h1>
      <p>
        Writes a lock for a given key in the driver
      </p>

      <section class="arguments">
        <h1>Arguments</h1>
        <ol>
          <li>
            <span class="name">key</span>
            (String|Array): The key to be locked
          </li>
        </ol>
      </section>

      <section class="returns">
        <h1>Returns</h1>
        (Promise): A Promise that will be resolved when the lock has been written
      </section>

      <section class="example">
        <h1>Example</h1>
        <pre>
          var driver = new OnionSkin.Driver.Redis();
          driver.lock(['my', 'key']).then(function () {
            // Key is now locked
          });
        </pre>
      </section>
    </section>

    <section id="onionskin-drivers-unlock">
      <h1>driver.unlock(key)</h1>
      <p>
        Removes a lock for a given key from the driver
      </p>

      <section class="arguments">
        <h1>Arguments</h1>
        <ol>
          <li>
            <span class="name">key</span>
            (String|Array): The key to be unlocked
          </li>
        </ol>
      </section>

      <section class="returns">
        <h1>Returns</h1>
        (Promise): A Promise that will be resolved when the lock has been removed
      </section>

      <section class="example">
        <h1>Example</h1>
        <pre>
          var driver = new OnionSkin.Driver.Redis();
          driver.unlock(['my', 'key']).then(function () {
            // Key is now unlocked
          });
        </pre>
      </section>
    </section>

    <section id="onionskin-drivers-islocked">
      <h1>driver.isLocked(key)</h1>
      <p>
        Check whether a key is locked or not
      </p>

      <section class="arguments">
        <h1>Arguments</h1>
        <ol>
          <li>
            <span class="name">key</span>
            (String|Array): The key to be unlocked
          </li>
        </ol>
      </section>

      <section class="returns">
        <h1>Returns</h1>
        (Promise): A Promise that will be resolved with a boolean value indicating
        the key's lock state
      </section>

      <section class="example">
        <h1>Example</h1>
        <pre>
          var driver = new OnionSkin.Drivers.Memcached();
          driver.isLocked('my-key').then(function (locked) {
            if (locked) {
              // Cache is locked, what now?
            } else {
              // Cache is unlocked, keep going...
            }
          });
        </pre>
      </section>
    </section>
  </section>

  <section id="onionskin-drivers-utils">
    <h1>OnionSkin Drivers Utils</h1>
    <p>Basic helper functions to ensure consistency through the drivers</p>

    <section id="onionskin-drivers-utils-key">
      <h1>OnionSkin.Drivers.Utils.key([namespace], key)</h1>
      <p>
        Generate consistent keys based on namespace and key
      </p>

      <section class="arguments">
        <h1>Arguments</h1>
        <ol>
          <li>
            <span class="name">namespace</span>
            (String): The namespace where the key belongs
          </li>
          <li>
            <span class="name">key</span>
            (String|Array): The key to be parsed
          </li>
        </ol>
      </section>

      <section class="returns">
        <h1>Returns</h1>
        (String): The generated key
      </section>

      <section class="example">
        <h1>Example</h1>
        <pre>
          OnionSkin.Drivers.Utils.key('my/key');
          OnionSkin.Drivers.Utils.key(['my', 'key']);
          OnionSkin.Drivers.Utils.key('my-namespace', 'my/key');
          OnionSkin.Drivers.Utils.key('my-namespace', ['my', 'key']);
        </pre>
      </section>
    </section>

  <section id="onionskin-drivers-utils-assemble">
    <h1>OnionSkin.Drivers.Utils.assemble(value, [expiration], [key], [serialize])</h1>
    <p>
      Generates a consistent value to be stored by the drivers
    </p>

    <section class="arguments">
      <h1>Arguments</h1>
      <ol>
        <li>
          <span class="name">value</span>
          (*): The value that will be associated with the key
        </li>
        <li>
          <span class="name">expiration</span>
          (Integer): The expiration time or Date for the value
        </li>
        <li>
          <span class="name">key</span>
          (String): The already parsed key - used only for IndexedDB where the
          key is stored within the value
        </li>
        <li>
          <span class="name">serialize</span>
          (Boolean): Wether or not it should return the string representation of
          the object - defaults to true
        </li>
      </ol>
    </section>

    <section class="returns">
      <h1>Returns</h1>
      (String|Object): The normalized object, either as string, if serialize is
      true, or as an object otherwise
    </section>

    <section class="example">
      <h1>Example</h1>
      <pre>
        OnionSkin.Drivers.Utils.assemble('my value');
        OnionSkin.Drivers.Utils.assemble('my value', 180);
        OnionSkin.Drivers.Utils.assemble('my value', 180, 'my/key');
        OnionSkin.Drivers.Utils.assemble('my value', 180, 'my/key', false);
      </pre>
    </section>
  </section>
</section>

</main>
</body>
</html>
